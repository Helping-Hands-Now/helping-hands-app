/* eslint-disable promise/no-nesting */
var functions = require("firebase-functions");
var { getE164PhoneNumber } = require("./../utils");
const moment = require("moment");
const email = require("./../notifications/email");
const {
  INFO_ADDRESS,
  volunteerSignupEmailTemplate,
  volunteerSignupNoRequestsEmailTemplate,
} = require("./../notifications/email_templates");
const { requestsByStatus, openRequestsAtGeohash } = require("./../requests");

function createProfile(db, admin, data, context) {
  // Lazy initialization
  if (!admin) {
    admin = require("firebase-admin");
    admin.initializeApp();
  }
  db = db || admin.firestore();

  /* Error cases:
  1) not signed in
  2) invalid data provided - TODO
  3) user with that phone number already exists
  4) write fails in Firebase
  5) user object already exists
  6) user already have more than 5 beneficiaries created */

  if (!context.auth) {
    throw new functions.https.HttpsError(
      "unauthenticated",
      "User not authenticated."
    );
  }

  const isBeneficiaryProfile = data.isBeneficiaryProfile;
  const createdByUid = context.auth.token.user_id;

  const profileData = userProfileDataOnCreation(data, context, {
    isBeneficiaryProfile,
  });

  return db
    .collection("users")
    .where("phoneNumber", "==", profileData.phoneNumber)
    .get()
    .then((querySnapshot) => {
      var promises = [];
      querySnapshot.forEach((doc) => {
        promises.push(db.collection("users").doc(doc.id).get());
      });
      return Promise.all(promises);
    })
    .then((docs) => {
      if (docs.length > 0 && !isBeneficiaryProfile) {
        // Filter out beneficiary profiles (which are allowed to duplicate phone numbers)
        var nonBeneficiaryProfiles = [];
        for (var i = 0; i < docs.length; i++) {
          if (docs[i].data().createdBy === docs[i].id) {
            nonBeneficiaryProfiles.push(docs[i]);
          }
        }
        if (
          nonBeneficiaryProfiles.length > 0 &&
          nonBeneficiaryProfiles[0].data().createdBy !== createdByUid
        ) {
          admin.auth().deleteUser(createdByUid);
          throw new functions.https.HttpsError(
            "permission-denied",
            "This phone number is already in use. If you have made an account already, please log in.",
            (details = { label: "phone-used" })
          );
        }
      }
      return;
    })
    .then(() => {
      if (isBeneficiaryProfile) {
        // Create a new profile (with random UID generated by .add)

        return db
          .collection("users")
          .add(profileData)
          .then((docRef) => {
            console.log(
              `successfully create profile for user ${docRef.uid} by user ${createdByUid}`
            );
            return { uid: docRef.id, createdByUid: createdByUid };
          });
      } else {
        // Set a profile using the UID we already have (since user already has UID from auth)

        // First, check that a profile hasn't been created already
        return db
          .collection("users")
          .doc(createdByUid)
          .get()
          .then((doc) => {
            if (doc.exists) {
              throw new functions.https.HttpsError(
                "already-exists",
                "This account already exists. Try logging in instead.",
                (details = { label: "profile-exists" })
              );
            }
            return;
          })
          .then(() => {
            return db.collection("users").doc(createdByUid).set(profileData);
          })
          .then(() => {
            console.log(`successfully create profile for user ${createdByUid}`);
            sendVolunteerSignupEmail(db, createdByUid).catch((e) => {
              console.error("sendVolunteerSignupEmail failed:", e);
            });
            return { uid: createdByUid, createdByUid: createdByUid };
          });
      }
    })
    .then((result) => {
      return result;
    });
}

function sendVolunteerSignupEmail(db, uid) {
  /**
   * On signup, if user is a volunteer, sends a transactional email
   * to welcome them to the platform
   * @param {firestore.database} db
   * @param {string} uid
   */
  return db
    .collection("users")
    .doc(uid)
    .get()
    .then((doc) => {
      const volunteer = doc.data();
      // Check if user is volunteer
      if (volunteer.canHelp === true) {
        console.log(
          "User is a volunteer, attempting to send volunteer_signup email"
        );
        // Check if volunteer has no pending requests
        const checkPendingRequests = requestsByStatus(
          db,
          "pending_fulfilment",
          { helperUid: uid }
        ).then((requests) => {
          return requests.length === 0;
        });

        // Check that there are open requests in range
        const checkOpenRequests = openRequestsAtGeohash(
          db,
          volunteer.geohash,
          25
        ).then((requests) => {
          return requests.length > 0;
        });

        return Promise.all([checkPendingRequests, checkOpenRequests]).then(
          (checks) => {
            let emails = [];
            const toAddress = volunteer.email;
            const delay24h = moment().add(24, "hours").unix();
            const delay48h = moment().add(48, "hours").unix();

            if (checks.every(Boolean)) {
              emails.push(
                email.send(
                  db,
                  uid,
                  toAddress,
                  INFO_ADDRESS,
                  volunteerSignupEmailTemplate(volunteer),
                  { sendAt: delay24h }
                )
              );
            } else if (checks[0] === true && checks[1] === false) {
              // no requests available nearby upon signup
              emails.push(
                email.send(
                  db,
                  uid,
                  toAddress,
                  INFO_ADDRESS,
                  volunteerSignupNoRequestsEmailTemplate(volunteer),
                  { sendAt: delay24h }
                )
              );
            }

            return Promise.all(emails);
          }
        );
      }
      return;
    });
}

function updateProfile(db, admin, data, context) {
  // Lazy initialization
  if (!admin) {
    admin = require("firebase-admin");
    admin.initializeApp();
  }
  db = db || admin.firestore();

  /* Error cases:
  1) not signed in
  2) invalid data provided - TODO
  3) user with same phone number already exists
  4) write fails in Firebase */

  if (!context.auth) {
    throw new functions.https.HttpsError(
      "unauthenticated",
      "User not authenticated."
    );
  }

  // We've separated the variables here because we will want to validate them in the future
  const uid = context.auth.token.user_id;
  const profileData = userProfileDataOnEdit(data, {});

  return db
    .collection("users")
    .where("phoneNumber", "==", profileData.phoneNumber)
    .get()
    .then((querySnapshot) => {
      var promises = [];
      querySnapshot.forEach((doc) => {
        promises.push(db.collection("users").doc(doc.id).get());
      });
      return Promise.all(promises);
    })
    .then((docs) => {
      if (docs.length > 0) {
        // Filter out beneficiary profiles (which are allowed to duplicate phone numbers)
        var nonBeneficiaryProfiles = [];
        for (var i = 0; i < docs.length; i++) {
          if (docs[i].data().createdBy === docs[i].id) {
            nonBeneficiaryProfiles.push(docs[i]);
          }
        }
        if (
          nonBeneficiaryProfiles.length > 0 &&
          nonBeneficiaryProfiles[0].data().createdBy !== uid
        ) {
          throw new functions.https.HttpsError(
            "permission-denied",
            "Someone else is already using this phone number.",
            (details = { label: "phone-used" })
          );
        }
      }
      return;
    })
    .then(() => {
      console.log(`successfully updated profile for user ${uid}`);
      return db.collection("users").doc(uid).update(profileData);
    });
}

function userProfileDataOnCreation(
  data,
  context,
  { isPartnerVolunteer, isBeneficiaryProfile, includeRecipientInfo }
) {
  // We've separated the variables here because we will want to validate them in the future
  const createdByUid = context.auth.token.user_id;

  // if it's a partner volunteer, take the email from the data because it comes
  // from the CSV form. otherwise, default to the old logic of using the
  // auth'd users email if !isBeneficiaryProfile, or null
  const profileEmail = isPartnerVolunteer
    ? data.email
    : !isBeneficiaryProfile
    ? context.auth.token.email
    : null;

  // cutoff time in Central
  // All users created before this time don't have to fill out a background check to accept requests
  const cutoffDate = new Date("July 16, 2020 14:00:00").getTime() / 1000;
  var date = new Date();
  var now = date.getTime() / 1000;

  const firstName = data.firstName;
  const lastName = data.lastName;
  const gender = data.gender;
  const street = data.street;
  const city = data.city;
  const state = data.state;
  const zipCode = data.zipCode;
  const apartment = data.apartment || "";
  const phoneNumber = getE164PhoneNumber(data.phoneNumber);
  const geohash = data.geohash || "";
  const placeId = data.placeId || "";
  const photoUrl = data.photoUrl || "";
  const needsHelp = data.needsHelp || false;
  const canHelp = data.canHelp || false;
  const languages = data.languages || [];
  const aboutUser = data.aboutUser || "";
  const email = profileEmail;
  const createdAt = new Date();
  const updatedAt = new Date();

  let recipientInfo = {};
  // fields that apply when adding recipients for an organization
  if (includeRecipientInfo) {
    recipientInfo = {
      numRecipients: data.numRecipients || 1,
      dropoffInstructions: data.dropoffInstructions || "",
      userCreatedByType: "ORGANIZATION",
    };
  }

  const profileData = {
    firstName: firstName,
    lastName: lastName,
    gender: gender,
    street: street,
    city: city,
    ...(now > cutoffDate && { checkrVerified: false }),
    state: state,
    zipCode: zipCode,
    apartment: apartment,
    phoneNumber: phoneNumber,
    geohash: geohash,
    placeId: placeId,
    photoUrl: photoUrl ? photoUrl : null,
    needsHelp: needsHelp,
    canHelp: canHelp,
    languages: languages,
    createdBy: createdByUid,
    numCancellationsMadeToday: 0,
    aboutUser: aboutUser,
    email: email,
    timeCreated: createdAt,
    timeUpdated: updatedAt,
    ...recipientInfo,
  };

  return profileData;
}

async function checkExistingOrgVolunteer(db, admin, data, context) {
  // Lazy initialization
  if (!admin) {
    admin = require("firebase-admin");
    admin.initializeApp();
  }

  const email = data.email;

  return admin
    .auth()
    .getUserByEmail(email)
    .then(async (userRecord) => {
      let snapshot = await db.collection("users").doc(userRecord.uid).get();

      if (snapshot) {
        let userData = snapshot.data();
        userData.id = snapshot.id;
        return userData;
      } else {
        return null;
      }
    })
    .catch((e) => {
      return null;
    });

  // TODO: we could add this check too but we don't need
  // it yet since we can re-add without error.
  // let userOrgSnapshot = await db
  //   .collection("user_organizations")
  //   .where("userId", "==", doc.id)
  //   .where("role", "==", "VOLUNTEER")
  //   .get();

  // let filter = userOrgSnapshot.docs.filter(
  //   (userOrgDoc) =>
  //     userOrgDoc.exists && userOrgDoc.data().organizationId === data.orgId
  // );
  // if (filter.length !== 1) {
  //   return null;
  // }
}

function userProfileDataOnEdit(data, { includeRecipientInfo }) {
  // We've separated the variables here because we will want to validate them in the future

  const firstName = data.firstName;
  const lastName = data.lastName;
  const gender = data.gender;
  const street = data.street;
  const city = data.city;
  const state = data.state;
  const zipCode = data.zipCode;
  const apartment = data.apartment;
  const phoneNumber = getE164PhoneNumber(data.phoneNumber);
  const geohash = data.geohash;
  const placeId = data.placeId;
  const languages = data.languages;
  const aboutUser = data.aboutUser;
  const updatedAt = new Date();

  let recipientInfo = {};
  // fields that apply when adding recipients for an organization
  if (includeRecipientInfo) {
    recipientInfo = {
      numRecipients: data.numRecipients || 1,
      dropoffInstructions: data.dropoffInstructions || "",
    };
  }

  const profileData = {
    firstName: firstName,
    lastName: lastName,
    gender: gender,
    street: street,
    city: city,
    state: state,
    zipCode: zipCode,
    apartment: apartment,
    phoneNumber: phoneNumber,
    geohash: geohash,
    placeId: placeId,
    languages: languages,
    aboutUser: aboutUser,
    timeUpdated: updatedAt,
    ...recipientInfo,
  };

  return profileData;
}

module.exports = {
  createProfile,
  userProfileDataOnCreation,
  userProfileDataOnEdit,
  updateProfile,
  checkExistingOrgVolunteer,
};
